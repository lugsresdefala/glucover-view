import { pgTable, text, serial, integer, real, boolean, jsonb, timestamp, varchar } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";

// Re-export auth models
export * from "./models/auth";

// Import tables from auth for relations
import { users, patients } from "./models/auth";

// Evaluations table - now links to patients
export const evaluations = pgTable("evaluations", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id),
  patientId: integer("patient_id").references(() => patients.id),
  patientName: text("patient_name").notNull(),
  weight: real("weight").notNull(),
  gestationalWeeks: integer("gestational_weeks").notNull(),
  gestationalDays: integer("gestational_days").notNull(),
  usesInsulin: boolean("uses_insulin").notNull(),
  insulinRegimens: jsonb("insulin_regimens"),
  dietAdherence: text("diet_adherence").notNull(),
  glucoseReadings: jsonb("glucose_readings").notNull(),
  abdominalCircumference: real("abdominal_circumference"),
  abdominalCircumferencePercentile: real("abdominal_circumference_percentile"),
  recommendation: jsonb("recommendation"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const evaluationsRelations = relations(evaluations, ({ one }) => ({
  user: one(users, {
    fields: [evaluations.userId],
    references: [users.id],
  }),
  patient: one(patients, {
    fields: [evaluations.patientId],
    references: [patients.id],
  }),
}));

// Insert schema for evaluations database record
export const insertEvaluationDbSchema = createInsertSchema(evaluations).omit({
  id: true,
  createdAt: true,
});

// Types from Drizzle
export type EvaluationRecord = typeof evaluations.$inferSelect;
export type InsertEvaluationRecord = z.infer<typeof insertEvaluationDbSchema>;

// ========== Zod Schemas for Validation ==========

// Glucose reading for a specific time of day
// Sem insulina: jejum, posCafe1h, posAlmoco1h, posJantar1h (4 medidas)
// Com insulina: adiciona preAlmoco, preJantar, madrugada (7 medidas total)
export const glucoseReadingSchema = z.object({
  jejum: z.number().min(0).max(500).optional(),
  posCafe1h: z.number().min(0).max(500).optional(),
  preAlmoco: z.number().min(0).max(500).optional(),
  posAlmoco1h: z.number().min(0).max(500).optional(),
  preJantar: z.number().min(0).max(500).optional(),
  posJantar1h: z.number().min(0).max(500).optional(),
  madrugada: z.number().min(0).max(500).optional(),
}).passthrough();

export type GlucoseReading = z.infer<typeof glucoseReadingSchema>;

// Check if a glucose reading has at least one valid value
export function hasValidGlucoseValue(reading: GlucoseReading): boolean {
  return Object.values(reading).some((v) => typeof v === "number" && v > 0);
}

// Filter out empty readings
export function filterValidReadings(readings: GlucoseReading[]): GlucoseReading[] {
  return readings.filter(hasValidGlucoseValue);
}

// Insulin types available
export const insulinTypes = [
  "NPH",
  "Regular",
  "Lispro",
  "Asparte",
  "Glulisina",
  "Glargina",
  "Detemir",
  "Degludeca",
] as const;

export type InsulinType = typeof insulinTypes[number];

// Insulin regimen
export const insulinRegimenSchema = z.object({
  type: z.enum(insulinTypes),
  doseManhaUI: z.number().min(0).optional(),
  doseAlmocoUI: z.number().min(0).optional(),
  doseJantarUI: z.number().min(0).optional(),
  doseDormirUI: z.number().min(0).optional(),
});

export type InsulinRegimen = z.infer<typeof insulinRegimenSchema>;

// Patient evaluation input
export const patientEvaluationSchema = z.object({
  patientName: z.string().min(1, "Nome da paciente é obrigatório"),
  weight: z.number().min(30).max(200, "Peso deve estar entre 30 e 200 kg"),
  gestationalWeeks: z.number().min(1).max(42, "Semanas devem estar entre 1 e 42"),
  gestationalDays: z.number().min(0).max(6, "Dias devem estar entre 0 e 6"),
  usesInsulin: z.boolean(),
  insulinRegimens: z.array(insulinRegimenSchema).optional(),
  dietAdherence: z.enum(["boa", "regular", "ruim"]),
  glucoseReadings: z.array(glucoseReadingSchema),
  abdominalCircumference: z.number().min(0).max(500).optional(),
  abdominalCircumferencePercentile: z.number().min(0).max(100).optional(),
});

export type PatientEvaluation = z.infer<typeof patientEvaluationSchema>;

// Insert schema for new evaluation (Zod validation)
export const insertEvaluationSchema = patientEvaluationSchema;
export type InsertEvaluation = z.infer<typeof insertEvaluationSchema>;

// Stored evaluation with ID and recommendation
export interface StoredEvaluation extends PatientEvaluation {
  id: number;
  createdAt: string;
  userId?: string;
  recommendation?: ClinicalRecommendation;
}

// Clinical recommendation generated by AI
export interface ClinicalRecommendation {
  analysis: string;
  mainRecommendation: string;
  justification: string;
  nextSteps: string[];
  urgencyLevel: "info" | "warning" | "critical";
  guidelineReferences: string[];
}

// API response types
export interface AnalyzeResponse {
  evaluation: StoredEvaluation;
  recommendation: ClinicalRecommendation;
}

// Glucose targets according to DMG guidelines
export const glucoseTargets = {
  jejum: { min: 0, max: 95 },
  posPrandial1h: { min: 0, max: 140 },
  posPrandial2h: { min: 0, max: 120 },
} as const;

// Critical thresholds for alerts
export const criticalGlucoseThresholds = {
  hypo: 60, // Below this is hypoglycemia
  severeHyper: 200, // Above this is severe hyperglycemia
} as const;

// Helper to check if glucose is within target
export function isGlucoseWithinTarget(value: number, type: "jejum" | "posPrandial1h" | "posPrandial2h"): boolean {
  const target = glucoseTargets[type];
  return value >= target.min && value <= target.max;
}

// Check for critical glucose values
export interface CriticalAlert {
  type: "hypoglycemia" | "severe_hyperglycemia";
  value: number;
  timepoint: string;
  day: number;
}

export function checkCriticalGlucose(readings: GlucoseReading[]): CriticalAlert[] {
  const alerts: CriticalAlert[] = [];
  const timepointLabels: Record<string, string> = {
    jejum: "Jejum",
    posCafe1h: "1h pós-café",
    preAlmoco: "Pré-almoço",
    posAlmoco1h: "1h pós-almoço",
    posAlmoco2h: "2h pós-almoço", // legado - mantido para compatibilidade
    preJantar: "Pré-jantar",
    posJantar1h: "1h pós-jantar",
    posJantar2h: "2h pós-jantar", // legado - mantido para compatibilidade
    madrugada: "Madrugada (3h)",
  };

  readings.forEach((reading, dayIndex) => {
    Object.entries(reading).forEach(([key, value]) => {
      if (typeof value === "number") {
        if (value < criticalGlucoseThresholds.hypo) {
          alerts.push({
            type: "hypoglycemia",
            value,
            timepoint: timepointLabels[key] || key,
            day: dayIndex + 1,
          });
        } else if (value > criticalGlucoseThresholds.severeHyper) {
          alerts.push({
            type: "severe_hyperglycemia",
            value,
            timepoint: timepointLabels[key] || key,
            day: dayIndex + 1,
          });
        }
      }
    });
  });

  return alerts;
}

// Calculate percentage of glucose readings within target
export function calculateGlucosePercentageInTarget(readings: GlucoseReading[]): number {
  let total = 0;
  let inTarget = 0;

  readings.forEach((reading) => {
    if (reading.jejum !== undefined) {
      total++;
      if (isGlucoseWithinTarget(reading.jejum, "jejum")) inTarget++;
    }
    if (reading.posCafe1h !== undefined) {
      total++;
      if (isGlucoseWithinTarget(reading.posCafe1h, "posPrandial1h")) inTarget++;
    }
    if (reading.preAlmoco !== undefined) {
      total++;
      if (isGlucoseWithinTarget(reading.preAlmoco, "jejum")) inTarget++;
    }
    if (reading.posAlmoco1h !== undefined) {
      total++;
      if (isGlucoseWithinTarget(reading.posAlmoco1h, "posPrandial1h")) inTarget++;
    }
    // Compatibilidade com dados legados usando 2h pós-almoço
    if (typeof reading.posAlmoco2h === "number") {
      total++;
      if (isGlucoseWithinTarget(reading.posAlmoco2h, "posPrandial2h")) inTarget++;
    }
    if (reading.preJantar !== undefined) {
      total++;
      if (isGlucoseWithinTarget(reading.preJantar, "jejum")) inTarget++;
    }
    if (reading.posJantar1h !== undefined) {
      total++;
      if (isGlucoseWithinTarget(reading.posJantar1h, "posPrandial1h")) inTarget++;
    }
    // Compatibilidade com dados legados usando 2h pós-jantar
    if (typeof reading.posJantar2h === "number") {
      total++;
      if (isGlucoseWithinTarget(reading.posJantar2h, "posPrandial2h")) inTarget++;
    }
    if (reading.madrugada !== undefined) {
      total++;
      if (isGlucoseWithinTarget(reading.madrugada, "jejum")) inTarget++;
    }
  });

  return total > 0 ? Math.round((inTarget / total) * 100) : 0;
}

// Calculate average glucose
export function calculateAverageGlucose(readings: GlucoseReading[]): number {
  let total = 0;
  let count = 0;

  readings.forEach((reading) => {
    Object.values(reading).forEach((value) => {
      if (typeof value === "number") {
        total += value;
        count++;
      }
    });
  });

  return count > 0 ? Math.round(total / count) : 0;
}
